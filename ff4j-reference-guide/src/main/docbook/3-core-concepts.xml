<?xml version="1.0" encoding="UTF-8"?>
<chapter id="3" xmlns="http://docbook.org/ns/docbook" version="5.0" xml:lang="en">

	<title>Core Concepts</title>
	
	    <!-- *********************************************************************************** -->
	    <!-- *** Feature Groups                                                              *** -->
	    <!-- *********************************************************************************** -->
		<section id="3-1">
			<title>Feature Groups</title>
			<para>Features can be gathered as group. It is then possible to toggle the whole group. This capability can be 
			useful for instance, if you want to group all the "user stories" of sprint in the same release.
			</para>
			
			<itemizedlist>
      		
      		 <listitem>
       			<para>Let's create a new XML file <filename>ff4j-group.xml</filename> to illustrate</para>
    			<programlisting language="xml">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;
&lt;features&gt;

 &lt;!-- Sample Feature Group --&gt;
 &lt;feature-group name="release-2.3"&gt;
   &lt;feature uid="users-story1" enable="false" /&gt;
   &lt;feature uid="users-story2" enable="false" /&gt;
 &lt;/feature-group&gt;

 &lt;feature uid="featA" enable="true"  /&gt;
 &lt;feature uid="featB" enable="false" /&gt;

&lt;/features&gt;</programlisting>
      		 </listitem>
      		 
      		 <listitem>
       			<para>Here is a sample utilisation of groups.</para>
    			<programlisting language="java">@Test
public void myGroupTest() {

   FF4j ff4j = new FF4j("ff4j-groups.xml");

   // Check features loaded
   assertEquals(4, ff4j.getFeatures().size());
   assertTrue(ff4j.exist("featA"));
   assertTrue(ff4j.exist("users-story1"));
   assertTrue(ff4j.getStore().existGroup("release-2.3"));
   System.out.println("Features loaded OK");

   // Given
   assertFalse(ff4j.check("users-story1"));
   assertFalse(ff4j.check("users-story2"));

   // When
   ff4j.enableGroup("release-2.3");

   // Then
   assertTrue(ff4j.check("users-story1"));
   assertTrue(ff4j.check("users-story2"));

}</programlisting>
      		 </listitem>
      		 
      		  <listitem>
       			<para>You can also access to all operation dynamically through the <varname>FeatureStore</varname></para>
    			<programlisting language="java">@Test
public void workWithGroupTest() {

   // Given
   FF4j ff4j = new FF4j("ff4j-groups.xml");
   assertTrue(ff4j.exist("featA"));

   // When
   ff4j.getStore().addToGroup("featA", "new-group");

   // Then
   assertTrue(ff4j.getStore().existGroup("new-group"));
   assertTrue(ff4j.getStore().readAllGroups().contains("new-group"));

   Map&lt;String, Feature&gt; myGroup = ff4j.getStore().readGroup("new-group");
   assertTrue(myGroup.containsKey("featA"));

   // A feature can be in a single group
   // Here changing => deleting the last element of a group => deleting the group
   ff4j.getStore().addToGroup("featA", "group2");
   assertFalse(ff4j.getStore().existGroup("new-group"));
}</programlisting>

    		 </listitem>
      		
      	   </itemizedlist>
		</section>
		
		<!-- *********************************************************************************** -->
		<section id="3-2">
			<title>Aspect Oriented Programming (AOP)</title>
			
			<section id="3-2-1">
				<title>Overview</title>
				  <para>From the beginning of this guide, we use intrusive tests statements within source code to perform flipping like in : </para>
				  <programlisting language="java">if (ff4j.check("featA")) {
  // new code
} else {
  // legacy
}</programlisting>

			<para>This approach is quite intrusive into source code. You can nested different feature toggles at you may consider to clean often your 
			code and remove obsolete features. A good alternative is to rely on <ulink url="http://en.wikipedia.org/wiki/Dependency_Injection">Dependency Injection</ulink>, 
			also called Inversion of control (ioc) to choose the correct implementation of the service at runtime.</para>
			
			<para>Ff4j provide the <varname>@Flip</varname> annotation to perform flipping on methods using AOP proxies. At runtime, the target service is proxified by the ff4j 
			component which choose an implementation instead of another using feature status (enable/disable). It leverage on Spring AOP Framework.
			</para>
			
			</section>
			
			<section id="3-2-2">
				<title>Illustrate with example</title>
				<para>In the following chapter, we modify the project created in getting started to illustrate
				flipping through aop</para>
			<itemizedlist>
			<listitem>
       			<para>Add the dependency to <filename>ff4j-aop</filename> in your project</para>
    			<programlisting language="xml">&lt;dependency&gt;
 &lt;groupId>org.ff4j&lt;/groupId&gt;
  &lt;artifactId>ff4j-aop&lt;/artifactId&gt;
  &lt;version>1.2.0&lt;/version&gt;
&lt;/dependency&gt;</programlisting>
    		</listitem>
    		
			<listitem>
       			<para>Define a sample interface with the annotation : </para>
       			 <programlisting language="java">public interface GreetingService {

   @Flip(name="language-french", alterBean="greeting.french")
   String sayHello(String name);

}</programlisting>
			</listitem>
			
			<listitem>
       			<para>Define a first implementation, to tell hello in english </para>
       			 <programlisting language="java">@Component("greeting.english")
public class GreetingServiceEnglishImpl implements GreetingService {
    public String sayHello(String name) {
      return "Hello " + name;
    }
}</programlisting>
			</listitem>
			
			<listitem>
       			<para>Define a second implementation, to tell hello in french </para>
       			 <programlisting language="java">@Component("greeting.french")
public class GreetingServiceFrenchImpl implements GreetingService {
  public String sayHello(String name) {
    return "Bonjour " + name;
  }
}</programlisting>
			</listitem>
			
			<listitem>
       			<para>The AOP capability leverage on Spring Framework. To enable the Autoproxy, please ensure that the package <varname>org.ff4j.aop</varname> 
       			is scanned by spring at startup. The <filename>applicationContext-aop.xml</filename> should look like : </para>
       			 <programlisting language="xml">&lt;beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context="http://www.springframework.org/schema/context"
       xsi:schemaLocation="http://www.springframework.org/schema/beans 
           http://www.springframework.org/schema/beans/spring-beans-3.0.xsd
           http://www.springframework.org/schema/context
           http://www.springframework.org/schema/context/spring-context-3.0.xsd"&gt;
           
   &lt;context:component-scan base-package="org.ff4j.aop, org.ff4j.sample"/&gt;
   
  &lt;bean id="ff4j" class="org.ff4j.FF4j" &gt;
    &lt;property name="store" ref="ff4j.store.inmemory" /&gt;
  &lt;/bean&gt;

  &lt;bean id="ff4j.store.inmemory" class="org.ff4j.store.InMemoryFeatureStore" &gt;
    &lt;property name="location" value="ff4j-aop.xml" /&gt;
  &lt;/bean&gt;

&lt;/beans&gt;</programlisting>
			</listitem>
			
			<listitem>
			<para>Create a dedicated ff4j.xml file with the feature name <varname>language-french</varname> let's say <filename>ff4j-demo-aop.xml</filename></para>
			 <programlisting language="xml">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;
&lt;features&gt;
 &lt;feature uid="language-french" enable="false" /&gt;
&lt;/features&gt;</programlisting>
			</listitem>
			
			
			<listitem>
			<para>Demonstrate how does it work through a test :</para>
			 <programlisting language="java">import junit.framework.Assert;

import org.ff4j.FF4j;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.test.context.ContextConfiguration;
import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;

@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration("classpath:*applicationContext-aop.xml")
public class FeatureFlippingThoughAopTest {

    @Autowired
    private FF4j ff4j;

    @Autowired
    @Qualifier("greeting.english")
    private GreetingService greeting;

    @Test
    public void testAOP() {
        Assert.assertTrue(greeting.sayHello("CLU").startsWith("Hello"));
        ff4j.enable("language-french");
        Assert.assertTrue(greeting.sayHello("CLU").startsWith("Bonjour"));
    }

}</programlisting>
			</listitem>
			
		</itemizedlist>
			</section>
		</section>
		
		<!-- *********************************************************************************** -->
		<section id="3-3">
			<title>Permissions and security</title>
			
			<section id="3-3-1">
				<title>Overview</title>
				  <para>You may have to enable a feature only for a subset of your users. They are belong to a dedicated group or get a dedicated profile. 
				  With the <varname>Canary Realease</varname> pattern for instance, the feature could be activated only for beta-tester.
				  </para>
				  
				  <para>ff4j does not provideany  users/groups definition system but, instead, leverage on existing one like Spring Security or Apache Chiro. 
				  A set of permissions is defined for each feature but the permissions must already exists in the external security provider. Permissions will be checked
				  if, and only if, the feature is enabled.
				  </para>
				  
				  <figure id="fig-03-authds" floatstyle="center">
				  <title>AuthorizationManager sequence diagram</title>
				  <mediaobject role="bordered">
				   <imageobject role="web">
					<imagedata align="center" fileref="img/fig-03-sequencediagram-permissions.png" contentwidth="15cm" />
			  	  </imageobject>
				 </mediaobject>
				 </figure>
			</section>
			
			<section id="3-3-2">
				<title>AuthorizationManager</title>
				  <para>This is the class where ff4j evaluates users permissions against granted list at feature level. An implementation is available out-of-the-box to work
				  with <varname>Spring security</varname> framework. There are 2 methods to implements. The first one is retrieving current user profiles (to be tested against features ACL), and the
				  second will return a union of all permissions avaiable within the sysem. It's used in administration console to display permissions avec an editable list.</para>
				  
				  <figure id="fig-03-auth" floatstyle="center">
				  <title>AuthorizationManager UML Diagram</title>
				  <mediaobject>
				   <imageobject role="web">
					<imagedata align="center" fileref="img/fig-03-authmanager.png" contentwidth="7cm" />
			  	  </imageobject>
				 </mediaobject>
				 </figure>
			</section>
			
			<section id="3-3-3">
				<title>Illustrate through sample code</title>
				  <para>In this sample we will create a custom implementatino of <varname>AuthorizationManager</varname> which keep the list of permissions in Memory.</para>
				  
				  <itemizedlist>
					<listitem>
       					<para>There is no new extra required dependency to implement the <varname>AuthorizationManager</varname> is in the <filename>ff4j-core.jar</filename> file.
       					Here is a sample implementation.</para>
    				<programlisting language="java">public class CustomAuthorizationManager implements AuthorizationsManager {

  public static ThreadLocal&lt;String&gt; currentUserThreadLocal = new ThreadLocal&lt;String&gt;();

  private static final Map&lt;String, Set&lt;String&gt;&gt; permissions = new HashMap&lt;String, Set&lt;String&gt;&gt;();

  static {
    permissions.put("userA", new HashSet&lt;String&gt;(Arrays.asList("user", "admin", "beta")));
    permissions.put("userB", new HashSet&lt;String&gt;(Arrays.asList("user")));
    permissions.put("userC", new HashSet&lt;String&gt;(Arrays.asList("user", "beta")));
  }

  /** {@inheritDoc} */
  @Override
  public Set&lt;String&gt; getCurrentUserPermissions() {
    String currentUser = currentUserThreadLocal.get();
    return permissions.containsKey(currentUser) ? permissions.get(currentUser) : new HashSet&lt;String&gt;(); 
  }

  /** {@inheritDoc} */
  @Override
  public Set&lt;String&gt; listAllPermissions() {
    Set&lt;String> allPermissions = new HashSet&lt;String&gt;();
    for (Set&lt;String&gt; subPersmission : permissions.values()) {
      allPermissions.addAll(subPersmission);
    }
    return allPermissions;
  }

}</programlisting>
    			</listitem>
    			
    				<listitem>
       					<para>Create a <filename>ff4j.xml</filename> file with dedicated roles. 
       					A user will be able to use the <varname>sayHello</varname> feature it's enabled and if
       					he has the permission <varname>admin</varname>. In the same way a user can use <varname>sayGoodBye</varname>
       					if, and only if, he has the beta OR the user permission.  
       					</para>
    				<programlisting language="xml">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;
&lt;!DOCTYPE configuration&gt;
&lt;features&gt;

	&lt;feature uid="sayHello" description="my first feature" enable="true"&gt;
		&lt;security&gt;
			&lt;role name="admin" /&gt;
		&lt;/security&gt;
		
	&lt;/feature&gt;

	&lt;feature uid="sayGoodBye" description="null" enable="true"&gt;
		&lt;security&gt;
			&lt;role name="beta" /&gt;
			&lt;role name="user" /&gt;
		&lt;/security&gt;
	&lt;/feature&gt;
	
&lt;/features&gt;</programlisting>
    				</listitem>
    				
    				<listitem>
       					<para>Here is the unit test to illustrate : </para>
       					<programlisting language="java">@Test
public void sampleSecurityTest() {

  // Create FF4J
  FF4j ff4j = new FF4j("ff4j-security.xml");
  // Add the Authorization Manager Filter
  AuthorizationsManager authManager = new CustomAuthorizationManager();
  ff4j.setAuthorizationsManager(authManager);
  
  // Given : Feature exist and enable
  assertTrue(ff4j.exist("sayHello"));
  assertTrue(ff4j.getFeature("sayHello").isEnable());

  // Unknow user does not have any permission => check is false
  CustomAuthorizationManager.currentUserThreadLocal.set("unknown-user");
  System.out.println(authManager.getCurrentUserPermissions());
  assertFalse(ff4j.check("sayHello"));

  // userB exist bit he has not role Admin
  CustomAuthorizationManager.currentUserThreadLocal.set("userB");
  System.out.println(authManager.getCurrentUserPermissions());
  assertFalse(ff4j.check("sayHello"));

  // userA is admin
  CustomAuthorizationManager.currentUserThreadLocal.set("userA");
  System.out.println(authManager.getCurrentUserPermissions());
  assertTrue(ff4j.check("sayHello"));
}</programlisting>
 			   </listitem>
    		 </itemizedlist>
			</section>
			
			<section id="3-3-4">
				<title>Working with Spring Security</title>
				  <para>Even if creating a custom <varname>AuthorizationManager</varname> is possible, you may
				  want to use a well defined security framework such as Spring Security. The support of the framework
				  is provided out-of-the-box
				  </para>
				  
				 <itemizedlist>
					<listitem>
       					<para>Add the following dependency to your <filename>pom.xml</filename> file.</para>
    				<programlisting language="xml">&lt;dependency&gt;
 &lt;groupId>org.ff4j&lt;/groupId&gt;
  &lt;artifactId>ff4j-aop&lt;/artifactId&gt;
  &lt;version>1.2.0&lt;/version&gt;
&lt;/dependency&gt;</programlisting>
    				</listitem>
    				
    				<listitem>
       					<para>Define a spring security <varname>UserDetails</varname> implementation 
       					with the following <filename>applicationContext-security.xml</filename> file.</para>
    				<programlisting language="xml">&lt;beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context="http://www.springframework.org/schema/context"
       xsi:schemaLocation="http://www.springframework.org/schema/beans 
           http://www.springframework.org/schema/beans/spring-beans-3.0.xsd
           http://www.springframework.org/schema/context
           http://www.springframework.org/schema/context/spring-context-3.0.xsd"&gt;

  &lt;bean id="ff4j" class="org.ff4j.FF4j" &gt;
    &lt;property name="store" 					ref="ff4j.store.inmemory" /&gt;
    &lt;property name="authorizationsManager"	ref="ff4j.authorizationManager.spring" /&gt;
  &lt;/bean&gt;

  &lt;bean id="ff4j.store.inmemory" class="org.ff4j.store.InMemoryFeatureStore" &gt;
    &lt;property name="location" value="ff4j-security.xml" /&gt;
  &lt;/bean&gt;
  
  &lt;bean id="ff4j.authorizationManager.spring" class="org.ff4j.security.SpringSecurityAuthorisationManager" &gt;
  &lt;/bean&gt;

&lt;/beans&gt;</programlisting>
    				</listitem>
    				
    				<listitem>
       					<para>The <filename>ff4j-security.xml</filename> file has not changed from last sample</para>
    				<programlisting language="xml">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;
&lt;!DOCTYPE configuration&gt;
&lt;features&gt;

	&lt;feature uid="sayHello" description="my first feature" enable="true"&gt;
		&lt;security&gt;
			&lt;role name="admin" /&gt;
		&lt;/security&gt;
		
	&lt;/feature&gt;

	&lt;feature uid="sayGoodBye" description="null" enable="true"&gt;
		&lt;security&gt;
			&lt;role name="beta" /&gt;
			&lt;role name="user" /&gt;
		&lt;/security&gt;
	&lt;/feature&gt;
	
&lt;/features&gt;</programlisting>
    				</listitem>
    				
    				<listitem>
    				<para>Create the following test. It instanciates a spring security context and authenticate
    				a 'userA' with the permission 'beta'.</para>
    				<programlisting language="java">@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(locations = {"classpath:*applicationContext-security.xml"})
public class SampleSpringSecurityTest {

    @Autowired
    private FF4j ff4j;

    /** Security context. */
    private SecurityContext securityCtx;

    @Before
    public void setUp() throws Exception {
        securityCtx = SecurityContextHolder.getContext();

        // UserA got the roles : beta, user, admin
        List&lt;GrantedAuthority&gt; listOfRoles = new ArrayList&lt;GrantedAuthority&gt;();
        listOfRoles.add(new SimpleGrantedAuthority("beta"));
        User userA = new User("userA", "passwdA", listOfRoles);

        // Creadentials for UserA
        String userName = userA.getUsername();
        String passwd = userA.getPassword();
        UsernamePasswordAuthenticationToken token = new UsernamePasswordAuthenticationToken(userName, passwd, listOfRoles);
        token.setDetails(userA);

        // Create a security context with
        SecurityContext context = new SecurityContextImpl();
        context.setAuthentication(token);
        SecurityContextHolder.setContext(context);
    }

    @Test
    public void testIsAuthenticatedAndAuthorized() {

        // Given userA is authenticated in Spring
        Authentication auth = SecurityContextHolder.getContext().getAuthentication();
        Assert.assertTrue(auth.isAuthenticated());

        // UserA has not expected role 'admin'
        assertTrue(ff4j.exist("sayHello"));
        assertTrue(ff4j.getFeature("sayHello").isEnable());
        assertTrue(ff4j.getFeature("sayHello").getPermissions().contains("admin"));
        assertFalse(ff4j.check("sayHello"));

        // UserA has expected role 'beta'
        assertTrue(ff4j.exist("sayGoodBye"));
        assertTrue(ff4j.getFeature("sayGoodBye").isEnable());
        assertTrue(ff4j.getFeature("sayGoodBye").getPermissions().contains("beta"));
        assertTrue(ff4j.check("sayGoodBye"));
    }

    @After
    public void tearDown() {
        SecurityContextHolder.setContext(securityCtx);
    }
    				</programlisting>
    				</listitem>
    				
    			</itemizedlist>
    			
    			<note>
    			<para>
    				The spring security context has been here created in the test, in web applications, the security Context
    				within the HTTP thread with a <varname>ThreadLocal.</varname>
    			</para>
    			</note>
				  
			</section>
			
		</section>
		
		<!-- *********************************************************************************** -->
		<section id="3-4">
			<title>Flipping Strategy</title>
			<section id="3-4-1">
				<title>Overview</title>
				  
				  <para>As introduced in the first chapter, the behavior of a feature can be enslaved with your custom implementation and rules. With <varname>ff4j</varname>, once the
				  feature is enabled AND current authenticated user is granted, a test is performed to evaluate the value of <filename>FlippingStrategy</filename>.</para>
				 
				  <figure id="fig-03-stratseq" floatstyle="center">
				  <title>FlippingStrategy UML Diagram</title>
				  <mediaobject role="bordered">
				   <imageobject role="web">
					<imagedata align="center" fileref="img/fig-03-sequencediagram-strategy.png" contentwidth="15cm" />
			  	  </imageobject>
				 </mediaobject>
				 </figure>
				  
				  <para>
				  The class is set up with a map of "initial parameters" and the <varname>init(..)</varname> method must be implemented. The getter of those parameters must also be implemented
				  (for serialization purposes) and obviously the test is performed within <filename>evaluate(...)</filename> method.
				  </para>
				  
				  <figure id="fig-03-strat" floatstyle="center">
				  <title>FlippingStrategy UML Diagram</title>
				  <mediaobject role="bordered">
				   <imageobject role="web">
					<imagedata align="center" fileref="img/fig-03-flippingstrategy.png" contentwidth="7cm" />
			  	  </imageobject>
				 </mediaobject>
				 </figure>
				 
				 <para>
				 The <varname>evaluate()</varname> method expects a <varname>FlippingExecutionContext</varname> which hold parameters as key/value pairs 
				 and provides to you the feature name and a reference to the feature store.
				 </para>  
				 
			</section>
			
			<section id="3-4-3">
				<title>Illustrate custom strategies (1)</title>
				  <para>There is a bunch of strategies provided out-of-the-box but to understand the concept we propose to create our own. In this sample we will toggle feature
				  if, and only if the request is made during office time let's say 09:00 to 18:00.</para>
				  <itemizedlist>
					<listitem>
       					<para>There is no new extra required dependency to implement the <varname>FlippingStrategy</varname> is in the <filename>ff4j-core.jar</filename> file. Create the following class
       					strategy class. Note that it inherit from <varname>AbstractFlipStrategy</varname>, it's not mandatory but provide a bunch of helpers.</para>
    				<programlisting language="java">public class OfficeHoursFlippingStrategy extends AbstractFlipStrategy {

    /** Start Hour. */
    private int start = 0;

    /** Hend Hour. */
    private int end = 0;

    /** {@inheritDoc} */
    @Override
    public void init(String featureName, Map&lt;String, String&gt; initValue) {
        super.init(featureName, initValue);
        assertRequiredParameter("startDate");
        assertRequiredParameter("endDate");
        start = new Integer(initValue.get("startDate"));
        end = new Integer(initValue.get("endDate"));
    }

    /** {@inheritDoc} */
    @Override
    public boolean evaluate(String fName, FeatureStore fStore, FlippingExecutionContext ctx) {
        int currentHour = Calendar.getInstance().get(Calendar.HOUR_OF_DAY);
        return (currentHour &gt;= start &amp;&amp; currentHour &lt; end);
    }

}</programlisting>
    				</listitem>
    				
    				<listitem>
    					<para>Create a <varname>ff4j-strategy-1.xml</varname> with a feature reference our new strategy : </para>
    					<programlisting language="xml">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;
&lt;features&gt;

	&lt;feature uid="sayHello" enable="true" description="some desc"&gt;
		&lt;flipstrategy class="org.ff4j.sample.strategy.OfficeHoursFlippingStrategy" &gt;
			&lt;param name="startDate"&gt;9&lt;/param&gt;
			&lt;param name="endDate"&gt;18&lt;/param&gt;
		&lt;/flipstrategy&gt;
	&lt;/feature&gt;
		
&lt;/features&gt;</programlisting>
    				</listitem>
    				
    				<listitem>
    					<para>And the test to illustrate the behavior create the following unit test :</para>
    					<programlisting language="java">public class OfficeHoursFlippingStrategyTest  {
	
  // Initialization of target 'ff4j'
  private final FF4j ff4j = new FF4j("ff4j-strategy-1.xml");

  @Test
  public void testCustomStrategy() throws Exception {
    // Given
    assertTrue(ff4j.exist("sayHello"));
    FlippingStrategy fs = ff4j.getFeature("sayHello").getFlippingStrategy();
    assertTrue(fs.getClass() == OfficeHoursFlippingStrategy.class);
    assertEquals("9", fs.getInitParams().get("startDate"));
    
    // When
    int hour = Calendar.getInstance().get(Calendar.HOUR_OF_DAY);
    boolean isNowOfficeTime = (hour &gt; 9) &amp;&amp; (hour &lt; 18);
    
    // Then
    assertEquals(isNowOfficeTime, ff4j.check("sayHello"));
  }	
}</programlisting>
    				</listitem>
    				
    			</itemizedlist>
				  
				  
			</section>
			
			<section id="3-4-4">
				<title>Illustrate custom strategies (2)</title>
				  <para>This second sample will illustrate the <varname>FlippingExecutionContext</varname> behaviour. We create a strategy
				  to enable a feature only for a subset of geographical regions.
				  </para>
				  
				  <itemizedlist>
				  <listitem>
    					<para>Create a strategy, initialized with the granted regions and expected user region's within execution context : </para>
    					<programlisting language="java">
public class RegionFlippingStrategy extends AbstractFlipStrategy {

  /** initial parameter. */
  private static final String INIT_PARAMNAME_REGIONS = "grantedRegions";

  /** current user attribute */
  public static final String PARAMNAME_USER_REGION = "region";

  /** Initial Granted Regions. */
  private final Set&lt;String&gt; setOfGrantedRegions = new HashSet&lt;String&gt;();

  /** {@inheritDoc} */
  @Override
  public void init(String featureName, Map&lt;String, String&gt; initValue) {
    super.init(featureName, initValue);
    assertRequiredParameter(INIT_PARAMNAME_REGIONS);
    String[] arrayOfRegions = initValue.get(INIT_PARAMNAME_REGIONS).split(",");
    setOfGrantedRegions.addAll(Arrays.asList(arrayOfRegions));
  }

  /** {@inheritDoc} */
  @Override
  public boolean evaluate(String fName, FeatureStore fStore, FlippingExecutionContext ctx) {
    // true means required here
    String userRegion = ctx.getString(PARAMNAME_USER_REGION, true);
    return setOfGrantedRegions.contains(userRegion);
  }
}</programlisting>
    			  </listitem>
    			 
    			 <listitem>
    					<para>Create a xml file with a feature using the strategy : </para>
    					<programlisting language="xml">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;
&lt;features&gt;
  &lt;feature uid="notForEurop" enable="true" &gt;
    &lt;flipstrategy class="org.ff4j.sample.strategy.RegionFlippingStrategy" &gt;
      &lt;param name="grantedRegions"&gt;ASIA,AMER&lt;/param&gt;
    &lt;/flipstrategy&gt;
  &lt;/feature&gt;
&lt;/features&gt;</programlisting>
    			 </listitem>
    			 
    			 <listitem>
    					<para>Create the unit test : </para>
    					<programlisting language="java">public class RegionFlippingStrategyTest {

  // ff4j
  private final FF4j ff4j = new FF4j("ff4j-strategy-2.xml");

  // sample execution context
  private final FlippingExecutionContext fex = new FlippingExecutionContext();

  @Test
  public void testRegionStrategy() throws Exception {
    // Given
    assertTrue(ff4j.exist("notForEurop"));
    FlippingStrategy fs = ff4j.getFeature("notForEurop").getFlippingStrategy();
    assertTrue(fs.getClass() == RegionFlippingStrategy.class);
    assertEquals("ASIA,AMER", fs.getInitParams().get("grantedRegions"));

    // When
    fex.addValue(RegionFlippingStrategy.PARAMNAME_USER_REGION, "AMER");
    // Then
    assertTrue(ff4j.check("notForEurop", fex));

    // When
    fex.addValue(RegionFlippingStrategy.PARAMNAME_USER_REGION, "EUROP");
    // Then
    assertFalse(ff4j.check("notForEurop", fex));
  }
}</programlisting>
    			 </listitem>
    			 
    			 </itemizedlist>
				  
			</section>
			
			<section id="3-4-5">
				<title>Overriding Strategy</title>
				  <para>Sometimes, even if a feature has a defined strategy, you would like to override it for a single invocation. The <varname>FF4J</varname> 
				  class provides another <varname>check()</varname> method which take a flipping strategy as second parameter. The strategy will overrides the existing one.
				  </para>
				  
				  <itemizedlist>
				  <listitem>
    					<para>Here is a sample unit test to illustrate the behavior : </para>
    					<programlisting language="java">public class OverridingStrategyTest {
  // ff4j
  private final FF4j ff4j = new FF4j("ff4j-strategy-1.xml");

  @Test
  public void testBehaviourOfOverriding() {
    assertTrue(ff4j.exist("sayHello"));

    // Behaviour of the strategy
    FlippingStrategy fs = ff4j.getFeature("sayHello").getFlippingStrategy();
    assertTrue(fs.getClass() == OfficeHoursFlippingStrategy.class);
    assertEquals("9", fs.getInitParams().get("startDate"));
    int hour = Calendar.getInstance().get(Calendar.HOUR_OF_DAY);
    boolean isNowOfficeTime = (hour &gt; 9) &amp; (hour &lt; 18);
    assertEquals(isNowOfficeTime, ff4j.check("sayHello"));

    // New Strategy : ReleaseDate with date in the past ==&gt; Always true
    FlippingStrategy newStrategy = new ReleaseDateFlipStrategy(new Date(System.currentTimeMillis() - 100000));
    assertTrue(ff4j.checkOveridingStrategy("sayHello", newStrategy, null));
  }
}</programlisting>
    				</listitem>
				  
				  </itemizedlist>
				  
			</section>
			<section id="3-4-6">
				<title>Available Strategies</title>
				  <para>As previously detailed, a <varname>FlippingStrategy</varname> implements a custom logic to perform flipping. The ff4j framework provides a set of
				  strategies out-of-the-box.</para>
				  <section id="3-4-6-1">
					<title>Expression Language</title>
				  	<para>
				  	The idea behind this strategy is to evaluate a boolean expression by combining several feature with moore algebra. AND, OR, NOT and brackets are available. This way you
				  	can define features depending of status of other.
				  	</para>
				  	
				  <itemizedlist>
				    <listitem>
    					<para>Create a XML file, we want to check that feature 'D' is flipped if : <varname>(A AND B ) OR NOT(C) OR NOT(B)</varname>.
    					The expression is wrapped in a CDATA block. The charater for the
    					operand AND is <varname>&amp;</varname>, for OR it's <varname>|</varname> and for NOT it's <varname>!</varname></para>
    					<programlisting language="xml">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;
&lt;features&gt;
  &lt;feature uid="A" enable="true"  /&gt;
  &lt;feature uid="B" enable="false" /&gt;
  &lt;feature uid="C" enable="false" /&gt;
  &lt;feature uid="D" enable="true"&gt;
    &lt;flipstrategy class="org.ff4j.strategy.el.ExpressionFlipStrategy"&gt;
      &lt;param name="expression"&gt;&lt;![CDATA[A &amp; B | !C | !B]]&gt;&lt;/param&gt;
    &lt;/flipstrategy&gt;
  &lt;/feature&gt;
  &lt;feature uid="E" enable="true"&gt;
    &lt;flipstrategy class="org.ff4j.strategy.el.ExpressionFlipStrategy"&gt;
      &lt;param name="expression"&gt;&lt;![CDATA[A &amp; B]]&gt;&lt;/param&gt;
    &lt;/flipstrategy&gt;
  &lt;/feature&gt;
  &lt;feature uid="F" enable="true"&gt;
    &lt;flipstrategy class="org.ff4j.strategy.el.ExpressionFlipStrategy"&gt;
      &lt;param name="expression"&gt;&lt;![CDATA[A | B]]&gt;&lt;/param&gt;
    &lt;/flipstrategy&gt;
  &lt;/feature&gt;  
&lt;/features&gt;</programlisting>
    			    </listitem>
    			    
    			    <listitem>
    					<para>The behaviour is detailed in the following unit test</para>
    					<programlisting language="java">public class ExpressionStrategyTest {

  // ff4j
  private final FF4j ff4j = new FF4j("ff4j-strategy-expression.xml");

  @Test
   public void testExpressions() {

     // Given
     assertTrue(ff4j.exist("A"));
     assertTrue(ff4j.exist("B"));
     assertTrue(ff4j.exist("C"));
     ff4j.enable("D");
     ff4j.enable("E");
     ff4j.enable("F");

     // When A=FALSE, B=TRUE, C=TRUE
     assertFalse(ff4j.check("A"));
     assertTrue(ff4j.check("B"));
     assertTrue(ff4j.check("C"));

     // THEN
     // E = A AND B = FALSE AND TRUE = FALSE
     assertFalse(ff4j.check("E"));
     // F = A OR R = FALSE OR TRUE = TRUE
     assertTrue(ff4j.check("F"));
     // D = (A AND B) OR NOT(B) OR NOT(C) = (false &amp; true) or false or false
     assertFalse(ff4j.check("D"));

     // When enabling A
     ff4j.enable("A");

     // THEN
     // E = A AND B = TRUE AND TRUE = TRUE
     assertTrue(ff4j.check("E"));
     // F = A AND B = TRUE OR TRUE = TRUE
     assertTrue(ff4j.check("F"));
     // D = (A AND B) OR NOT(B) OR NOT(C) = (true &amp; true) or false or false
     assertTrue(ff4j.check("D"));
  }
}</programlisting>
    			    </listitem>
    			    
    			 </itemizedlist>
				  </section>
				  <section id="3-4-6-2">
					<title>ReleaseDate</title>
				  	<para>The purpose of this strategy is the made a feature available from a fixed date (like a releaseDate).
				  	Before the defined date, the feature is always false and after it's true. The format to set up the date is YYYY-MM-dd-HH:mm</para>
				  	<itemizedlist>
				    <listitem>
    					<para>Here a sample XML file : </para>
    					<programlisting language="xml">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;
&lt;features&gt;
  &lt;feature uid="PAST" enable="true" description="Always true as in the past"&gt;
    &lt;flipstrategy class="org.ff4j.strategy.ReleaseDateFlipStrategy" &gt;
      &lt;param name="releaseDate" value="2013-07-14-14:00" /&gt;
    &lt;/flipstrategy&gt;
  &lt;/feature&gt;
  &lt;feature uid="FUTURE" enable="true" description="Always false as in the (far) future"&gt; 
    &lt;flipstrategy class="org.ff4j.strategy.ReleaseDateFlipStrategy" &gt;
      &lt;param name="releaseDate" value="3013-07-14-14:00" /&gt;
    &lt;/flipstrategy&gt;
  &lt;/feature&gt;
&lt;/features&gt;</programlisting>
    				</listitem>
    				<listitem>
    					<para>And the related unit test : </para>
    					<programlisting language="java">public class ReleaseDateFlipStrategyTest  {

  // initialize ff4j
  FF4j ff4j = new FF4j("ff4j-strategy-releasedate.xml");

  @Test
  public void testReleaseDateStrategy() throws ParseException {

    // Given
    assertTrue(ff4j.exist("PAST"));
    Feature fPast = ff4j.getFeature("PAST");
    ReleaseDateFlipStrategy rdsPast = (ReleaseDateFlipStrategy) fPast.getFlippingStrategy();
    assertTrue(new Date().after(rdsPast.getReleaseDate()));
    // Then
    assertTrue(ff4j.check("PAST"));

    // Given
    assertTrue(ff4j.exist("FUTURE"));
    Feature fFuture = ff4j.getFeature("FUTURE");
    ReleaseDateFlipStrategy rdsFuture = (ReleaseDateFlipStrategy) fFuture.getFlippingStrategy();
    Assert.assertTrue(new Date().before(rdsFuture.getReleaseDate()));
    // Then
    assertFalse(ff4j.check("FUTURE"));
  }
}</programlisting>
    				</listitem>
    			   </itemizedlist>
				  	
				  </section>
				  
				  <section id="3-4-6-3">
					<title>ClientList Strategy</title>
				  	<para>The purpose of this strategy is to enable a feature for a limited list of clients. Each client must present its 'hostname' in the context. 
				  	If the hostname is in the white list, it's ok. The attribute to set up is <varname>clientHostName</varname>. The values are separated by a comma, there
				  	are no spaces between values.</para>
				  	
				  	<itemizedlist>
				  	 <listitem>
				  	    <para>Here a sample XML file : </para>
				  	    <programlisting language="xml">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;
&lt;!DOCTYPE configuration&gt;
&lt;features&gt;
  &lt;feature uid="pingCluster" enable="true" description="limit client hosts"&gt;
    &lt;flipstrategy class="org.ff4j.strategy.ClientFilterStrategy" &gt;
      &lt;param name="grantedClients"&gt;127.0.0.1,srvprd01,srvprd02&lt;/param&gt;
    &lt;/flipstrategy&gt;
  &lt;/feature&gt;
&lt;/features&gt;</programlisting>
				  	 </listitem>
				  	 <listitem>
				  	 	<para>And the related unit test : </para>
				  	    <programlisting language="java">public class ClientListStrategyTest {

  // initialize ff4j
  FF4j ff4j = new FF4j("ff4j-strategy-clientfilter.xml");

  @Test
  public void testClientFilter() {
    // Given
    assertTrue(ff4j.exist("pingCluster"));
    assertTrue(ff4j.getFeature("pingCluster").isEnable());

    // When no host provided, Then error
    try {
      assertFalse(ff4j.check("pingCluster"));
      fail(); // error as parameter not present in execution context
    } catch (IllegalArgumentException iae) {
      assertTrue(iae.getMessage().contains(ClientFilterStrategy.CLIENT_HOSTNAME));
    }

    // When invalid host provided, Then unavailable
    FlippingExecutionContext fex = new FlippingExecutionContext();
    fex.addValue(ClientFilterStrategy.CLIENT_HOSTNAME, "invalid");
    assertFalse(ff4j.check("pingCluster", fex));

    // When correct hostname... OK
    fex.addValue(ClientFilterStrategy.CLIENT_HOSTNAME, "srvprd01");
    assertTrue(ff4j.check("pingCluster", fex));
  }
}</programlisting>
				  	 </listitem>
				  	</itemizedlist>
				  	
				  </section>
				  
				  <section id="3-4-6-4">
					<title>ServerFilterList Strategy</title>
				  	<para>The purpose of this strategy is to enable a feature for a limited list of servers. The feature will be available only if the hostname of hosting server
				  	is in the white list. The attribute to set up is <varname>serverHostName</varname> but it'not required. If not provided ff4j will ask the JVM for the current
				  	hostname (through the <varname>InetAddress</varname>) The values are separated by a comma, there are no spaces between values.</para>
				  	<itemizedlist>
				  	 <listitem>
				  	    <para>Here a sample XML file : </para>
				  	    <programlisting language="xml">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;
&lt;!DOCTYPE configuration&gt;
&lt;features&gt;
  &lt;feature uid="onlyOnPRODServers" enable="true" description="some desccheck hostname"&gt;
    &lt;flipstrategy class="org.ff4j.strategy.ServerFilterStrategy" &gt;
      &lt;param name="grantedServers"&gt;srvprd01,srvprd02,srvprd03&lt;/param&gt;
    &lt;/flipstrategy&gt;
  &lt;/feature&gt;
 &lt;/features&gt; 
</programlisting>
					 </listitem>
					 
				  	 <listitem>
				  	 	<para>And the related unit test : </para>
				  	    <programlisting language="java">public class ServerListStrategyTest {

  // initialize ff4j
  FF4j ff4j = new FF4j("ff4j-strategy-serverfilter.xml");

  @Test
  public void testServerFilter() throws UnknownHostException {
    // Given
    assertTrue(ff4j.exist("onlyOnPRODServers"));
    assertTrue(ff4j.getFeature("onlyOnPRODServers").isEnable());

    // When invalid host provided, Then unavailable
    FlippingExecutionContext fex = new FlippingExecutionContext();
    fex.addValue(ServerFilterStrategy.SERVER_HOSTNAME, "invalid");
    assertFalse(ff4j.check("onlyOnPRODServers", fex));

    // When correct hostname... OK
    fex.addValue(ServerFilterStrategy.SERVER_HOSTNAME, "srvprd01");
    assertTrue(ff4j.check("onlyOnPRODServers", fex));

    // When no host provided, Then try to identified by itself but not SECURE
    System.out.println("Trying..." + InetAddress.getLocalHost().getHostName() + " against white list");
    // my laptop hostname is not in the whitelist
    assertFalse(ff4j.check("onlyOnPRODServers"));
  }
}</programlisting>
				  	 </listitem>
				  	 
				    </itemizedlist>
				  	
				  </section>
				  
				   <section id="3-4-6-5">
					<title>Ponderation</title>
				  	<para>The purpose of this strategy is to enable a feature for a percentage of requests. It could be useful in 
				  	<link linkend='1-3-1-2'>Dark Launch</link> zero downtime deployment pattern for instance. It expected a parameter
				  	<varname>weight</varname> but if not provided is set up to its default value 0.5</para>
				  	<itemizedlist>
				  	
				  	  <listitem>
				  	    <para>Here a sample XML file : </para>
				  	    <programlisting language="xml">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;
&lt;!DOCTYPE configuration&gt;
&lt;features&gt;

  &lt;!-- Ponderation to 0 --&gt;
  &lt;feature uid="pond_0"  enable="true" description="some desc"&gt;
    &lt;flipstrategy class="org.ff4j.strategy.PonderationStrategy" &gt;
      &lt;param name="weight" value="0" /&gt;
    &lt;/flipstrategy&gt;
  &lt;/feature&gt;
			
  &lt;!-- Ponderation to 1 --&gt;
  &lt;feature uid="pond_1" enable="true" description="some desc" &gt;
    &lt;flipstrategy class="org.ff4j.strategy.PonderationStrategy" &gt;
      &lt;param name="weight" value="1" /&gt;
    &lt;/flipstrategy&gt;
  &lt;/feature&gt;
	
  &lt;feature uid="pond_06"  enable="true" description="some desc"&gt; 
    &lt;flipstrategy class="org.ff4j.strategy.PonderationStrategy" &gt;
      &lt;param name="weight" value="0.6" /&gt;
    &lt;/flipstrategy&gt;
  &lt;/feature&gt;
	
  &lt;feature uid="pondDefault" enable="true" description="some desc"&gt;
    &lt;flipstrategy class="org.ff4j.strategy.PonderationStrategy" /&gt;
  &lt;/feature&gt;
		
&lt;/features&gt;</programlisting>
				  	  </listitem>
 					
 					  <listitem>
				  	 	<para>And the related unit test : </para>
				  	    <programlisting language="java">public class PonderationFlippingStrategyTest {

  // initialize ff4j
  FF4j ff4j = new FF4j("ff4j-strategy-ponderation.xml");

  @Test
  public void testPonderation() {
    
    // Given : weight = 0
    assertTrue(ff4j.exist("pond_0"));
    // Then => always false
    assertFalse(ff4j.check("pond_0"));

    // Given : weight = 100%
    assertTrue(ff4j.exist("pond_1"));
    // Then => Always true
    assertTrue(ff4j.check("pond_1"));

    // Given : weight = 60%
    assertTrue(ff4j.exist("pond_06"));
    // When : Try 1 million times
    double success = 0.0;
    for (int i = 0; i &lt; 1000000; i++) {
       if (ff4j.check("pond_06")) {
         success++;
       }
    }
    // Then, percentage ok with great precision
    double resultPercent = success / 1000000;
    assertTrue(resultPercent &lt; (0.6 + 0.001));
    assertTrue(resultPercent &gt; (0.6 - 0.001));
  }
}</programlisting>
				  	  </listitem>
				  	  </itemizedlist>
				  	  
				  </section>
				  
			</section>
			
		</section>
		
		<!-- ************************************************************** -->
		<!-- *** STORES                                                 *** -->
		<!-- ************************************************************** -->
		
		<section id="3-5">
			<title>Feature Stores</title>
			
			<section id="3-5-1">
				<title>Introduction</title>
				<para>As already introduced in getting started the <varname>FeatureStore</varname> is the persistent unit whare are saved the features with their attributes and status.
				It proposes a set of CRUD operations to work with features but also, groups of features, and, permissions on features.</para>
				
				<figure id="fig-03-featurestore" floatstyle="center">
				  <title>Feature Store</title>
				  <mediaobject role="bordered">
				    <imageobject role="web">
					  <imagedata align="center" fileref="img/fig-02-featurestore.png" contentwidth="6cm" />
					</imageobject>
				  </mediaobject>
				</figure>
				
				<para>The <varname>FeatureStore</varname> is only an interface and several implementations are available for different kind of storage middleware. All examples in this
				guide have been written using the simplest yet less powerful store the default InMemeoryStore relying on XML, with other stores any modifications perform on features are kept.</para>
					
				  	<section id="3-5-1-1">
					 <title>Objectives</title>
				  	 <para>There are multiple purposed of the store  : </para>
				  	 
				  	 <itemizedlist>
				  	 	<listitem><para>It allows to enable or disable features AT RUNTIME.</para></listitem>
				  	 	<listitem><para>It allows to PERSIST status of features even when restarting applications (except for InMemoryStore/XML stores).</para></listitem>
				  	 	<listitem><para>It allows to synchronized status of features between DIFFERENT APPLICATIONS (except for InMemoryStore/XML stores)</para></listitem>
				  	 </itemizedlist>
				  	
				    </section>
				    
				    <section id="3-5-1-2">
					  <title>Architecture Patterns</title>
				  	  <para>An "embedded" or "in memory" <varname>FeatureStore</varname> has 2 main drawbacks. The modifications performed at runtime are lost when restarting, 
				  	  you cannot be consistent in a cluster with several nodes. Yet it's the most fast. You must consider your production environment requirements to make good choices.</para>
				  	  <figure id="fig-03-archipattern" floatstyle="center">
				  	 	<title>Embedded vs Externalized Store</title>
				     	<mediaobject role="bordered">
				      	<imageobject role="web">
					    	<imagedata align="center" fileref="img/fig-03-archipatterns.png" contentwidth="12cm" />
						</imageobject>
				  		</mediaobject>
					  </figure>
				    </section>
				    
			</section>
			
			<section id="3-5-2">
			  <title>InMemoryFeatureStore</title>
			  <para>The implementation of this <varname>FeatureStore</varname> parses an XML document (file or stream) at startup and store the features as a ConcurrentHashMap in memory. It's the default
			  implementation of FF4J. It does not required any external librairies and is available in the module <varname>ff4j-core</varname>. The XML schema of the file (or XSD) can be find there.
			  <ulink url="http://ff4j.org/schema/ff4j.xsd">http://ff4j.org/schema/ff4j.xsd</ulink> 
			  </para>
			  
			  <para>You can declared the schema in the XML file with the following schema : </para>
			  <programlisting language="xml">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;
&lt;features xmlns="http://www.ff4j.org/schema/ff4j" 
     xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	 xsi:schemaLocation="http://www.ff4j.org/schema/ff4j http://ff4j.org/schema/ff4j.xsd"&gt;
  &lt;!-- Here your declarations -- &gt;
&lt;/features&gt;</programlisting>

			  <para>There are a lot of samples in this reference guide. Yet, let's summarize everything in a quite complete one </para>
			   <programlisting language="xml">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;
&lt;features xmlns="http://www.ff4j.org/schema/ff4j" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://www.ff4j.org/schema/ff4j http://ff4j.org/schema/ff4j.xsd"&gt;

  &lt;!-- Simplest --&gt;
  &lt;feature uid="A" enable="true" /&gt;

  &lt;!-- Add description --&gt;
  &lt;feature uid="B" description="Expect to say good bye..." enable="false" /&gt;

  &lt;!-- Security stuff --&gt;
  &lt;feature uid="C" enable="false"&gt;
    &lt;security&gt;
      &lt;role name="USER"  /&gt;
	  &lt;role name="ADMIN" /&gt;
	&lt;/security&gt;
  &lt;/feature&gt;

  &lt;!-- Some strategies and a group --&gt;
  &lt;feature-group name="strategies"&gt;
		
    &lt;feature uid="S1" enable="true"&gt;
	  &lt;flipstrategy class="org.ff4j.strategy.el.ExpressionFlipStrategy"&gt;
        &lt;param name="expression" value="A | B" /&gt;
      &lt;/flipstrategy&gt;
    &lt;/feature&gt;

    &lt;feature uid="S2" enable="true"&gt;
      &lt;flipstrategy class="org.ff4j.strategy.ReleaseDateFlipStrategy"&gt;
        &lt;param name="releaseDate" value="2013-07-14-14:00" /&gt;
      &lt;/flipstrategy&gt;
    &lt;/feature&gt;

    &lt;feature uid="S3" description="null" enable="true"&gt;
      &lt;flipstrategy class="org.ff4j.strategy.PonderationStrategy"&gt;
        &lt;param name="weight" value="0.5" /&gt;
      &lt;/flipstrategy&gt;
    &lt;/feature&gt;

    &lt;feature uid="S4" description="z" enable="true"&gt;
      &lt;flipstrategy class="org.ff4j.strategy.ClientFilterStrategy"&gt;
        &lt;param name="grantedClients" value="c1,c2" /&gt;
      &lt;/flipstrategy&gt;
    &lt;/feature&gt;

    &lt;feature uid="S5" description="null" enable="true"&gt;
      &lt;flipstrategy class="org.ff4j.strategy.ServerFilterStrategy"&gt;
        &lt;param name="grantedServers" value="s1,s2" /&gt;
      &lt;/flipstrategy&gt;
    &lt;/feature&gt;
		
  &lt;/feature-group&gt;
&lt;/features&gt;</programlisting>

			<para>The XML format can be generated whatever the <varname>FeatureStore</varname> configured. It should be use to export configuration from an environment
			and insert into another. As detailed further, this operation is available in the web console.</para>
			
			  <figure id="fig-03-export" floatstyle="center">
				  <title>Export and Imports actions in web console</title>
				  <mediaobject role="bordered">
				   <imageobject role="web">
					<imagedata align="center" fileref="img/fig-03-export-import.png" contentwidth="12cm" />
			  	  </imageobject>
				 </mediaobject>
				 </figure>
				 
			<para>If you would like to do it in your own code, here is the way to do it.</para>
			<programlisting language="java">public class ImportExportXmlTest {

    @Test
    public void testImport() throws FileNotFoundException {
        // Given
        FF4j ff4j = new FF4j();
        // When
        FileInputStream fis = new FileInputStream(new File("src/test/resources/ff4j.xml"));
        Map&lt;String, Feature&gt; mapsOfFeat = new FeatureXmlParser().parseConfigurationFile(fis);
        for (Entry&lt;String, Feature&gt; feature : mapsOfFeat.entrySet()) {
            if (ff4j.exist(feature.getKey())) {
                ff4j.getStore().update(feature.getValue());
            } else {
                ff4j.getStore().create(feature.getValue());
            }
        }
        // Then
        assertEquals(2, ff4j.getFeatures().size());
    }
    
    @Test
    public void testExport() throws IOException {
        FF4j ff4j = new FF4j("ff4j.xml");
        
        InputStream in = ff4j.exportFeatures();

        // Write into console
        byte[] bbuf = new byte[4096];
        int length = 0;
        while ((in != null) &amp;&amp; (length != -1)) {
            length = in.read(bbuf);
        }
        System.out.print(new String(bbuf));
    }
}</programlisting>
			  
			</section>
			
			<section id="3-5-3">
			  <title>Relational Database FeatureStore</title>
			  <para>The first store to externalize feature is to rely on a "database", a relational database to be exact. It's accessed through the
			  Java Database Connectivity API, JDBC. 
			  </para>
			  	<section id="3-5-3-1">
				 <title>Data Model</title>
				   <para>Status, crud, storage,Sed egestas molestie elit. Mauris urna mi, scelerisque vitae, ultrices vel, euismod vel, eros. 
				  	 Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Pellentesque dictum felis a nisi. </para>
				  	 <programlisting language="sql">-- Main Table to store Features
CREATE TABLE FF4J_FEATURES (
  "FEAT_UID"     	VARCHAR(100),
  "ENABLE"  		INTEGER NOT NULL,
  "DESCRIPTION" 	VARCHAR(255),
  "STRATEGY"		VARCHAR(255),
  "EXPRESSION"	    VARCHAR(255),
  "GROUPNAME"		VARCHAR(255),
  PRIMARY KEY("FEAT_UID")
);

-- Roles to store ACL, FK to main table
CREATE TABLE FF4J_ROLES (
  "FEAT_UID"     VARCHAR(50) REFERENCES FF4J_FEATURES("FEAT_UID"),
  "ROLE_NAME"    VARCHAR(50),
  PRIMARY KEY("FEAT_UID", "ROLE_NAME")
);</programlisting>
				 </section>
				 <section id="3-5-3-2">
				 <title>Core JDBC</title>
				   <para>Status, crud, storage,Sed egestas molestie elit. Mauris urna mi, scelerisque vitae, ultrices vel, euismod vel, eros. 
				  	 Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Pellentesque dictum felis a nisi. </para>
				 </section>
				 <section id="3-5-3-3">
				 <title>Spring JDBC</title>
				   <para>Status, crud, storage,Sed egestas molestie elit. Mauris urna mi, scelerisque vitae, ultrices vel, euismod vel, eros. 
				  	 Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Pellentesque dictum felis a nisi. </para>
				 </section>
			</section>
			
			<section id="3-5-4">
			  <title>MongoDB FeatureStore</title>
			  <para>Status, crud, storage,Sed egestas molestie elit. Mauris urna mi, scelerisque vitae, ultrices vel, euismod vel, eros. 
				  	 Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Pellentesque dictum felis a nisi. </para>
				 <section id="3-5-4-1">
				  <title>Overview</title>
				   <para>Status, crud, storage,Sed egestas molestie elit. Mauris urna mi, scelerisque vitae, ultrices vel, euismod vel, eros. 
				  	 Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Pellentesque dictum felis a nisi. </para>
				 </section>
				 <section id="3-5-4-2">
				  <title>Sample Code</title>
				   <para>Status, crud, storage,Sed egestas molestie elit. Mauris urna mi, scelerisque vitae, ultrices vel, euismod vel, eros. 
				  	 Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Pellentesque dictum felis a nisi. </para>
				 </section>
			</section>
			
			<section id="3-5-5">
			  <title>Remote HTTP (client) FeatureStore</title>
			  <para>Status, crud, storage,Sed egestas molestie elit. Mauris urna mi, scelerisque vitae, ultrices vel, euismod vel, eros. 
				  	 Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Pellentesque dictum felis a nisi. </para>
				 <section id="3-5-5-1">
				  <title>Overview</title>
				   <para>Status, crud, storage,Sed egestas molestie elit. Mauris urna mi, scelerisque vitae, ultrices vel, euismod vel, eros. 
				  	 Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Pellentesque dictum felis a nisi. </para>
				 </section>
				 <section id="3-5-5-2">
				  <title>Sample Code</title>
				   <para>Status, crud, storage,Sed egestas molestie elit. Mauris urna mi, scelerisque vitae, ultrices vel, euismod vel, eros. 
				  	 Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Pellentesque dictum felis a nisi. </para>
				 </section>
			</section>
			
		</section>
		
		<!-- *********************************************************************************** -->
		<section id="3-6">
			<title>Caching</title>
			<para>Text here</para>
			 
			 <section id="3-6-1">
			 	<title>Architecture Concerns</title>
				<para> Status, crud, storage,Sed egestas molestie elit. Mauris urna mi, scelerisque vitae, ultrices vel, euismod vel, eros. 
				Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Pellentesque dictum felis a nisi. </para>
			 </section>
			
			  <section id="3-6-2">
				<title>Working with EHCache</title>
				<para>Status, crud, storage,Sed egestas molestie elit. Mauris urna mi, scelerisque vitae, ultrices vel, euismod vel, eros. 
				Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Pellentesque dictum felis a nisi. </para>
			  </section>
			  
			  <section id="3-6-3">
				<title>Working with Redis</title>
				<para>Status, crud, storage,Sed egestas molestie elit. Mauris urna mi, scelerisque vitae, ultrices vel, euismod vel, eros. 
				Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Pellentesque dictum felis a nisi. </para>
		      </section>
			 
		</section>
		
		<!-- *********************************************************************************** -->
		<section id="3-7">
			<title>Monitoring</title>
			<para>Text here</para>
			
			 <section id="3-7-1">
			 	<title>Overview</title>
				<para> Status, crud, storage,Sed egestas molestie elit. Mauris urna mi, scelerisque vitae, ultrices vel, euismod vel, eros. 
				Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Pellentesque dictum felis a nisi. </para>
			 </section>
			 
			  <section id="3-7-2">
			 	<title>Metrics</title>
				<para>Usage vs actions, exporter
				Status, crud, storage,Sed egestas molestie elit. Mauris urna mi, scelerisque vitae, ultrices vel, euismod vel, eros. 
				Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Pellentesque dictum felis a nisi. </para>
			 </section>
			 
			 <section id="3-7-3">
			 	<title>Curves and Graphics</title>
				<para>Usage vs actions, exporter
				Status, crud, storage,Sed egestas molestie elit. Mauris urna mi, scelerisque vitae, ultrices vel, euismod vel, eros. 
				Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Pellentesque dictum felis a nisi. </para>
			 </section>
		</section>
		
</chapter>
